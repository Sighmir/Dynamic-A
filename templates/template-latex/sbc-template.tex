\documentclass[12pt]{article}

\usepackage{sbc-template}

\usepackage{graphicx,url}

%\usepackage[brazil]{babel}   
\usepackage[latin1]{inputenc}  

     
\sloppy

\title{A* para qualquer configuração de vizinhos}

\author{Guilherme Caulada\inst{1}, Pedro Cacique\inst{1} }


\address{Faculdade de Computação e Informática -- Universidade Presbiteriana Mackenzie
  (UPM)\\
  R. da Consolação, 930 - Consolação, São Paulo - SP, 01302-907 - Brazil
  \email{guistoppa1995@gmail.com, phcacique@gmail.com}
}

\begin{document} 

\maketitle

\begin{abstract}
The A* algorithm is the most used in the game and robotics industry, although it is
one of the best pathfinding algorithms out there, the pre-processing necessary in its
original implementation makes it hard to execute this algorithm in a dynamic environment.
To address that issue, this paper explores the possibility of making A* more flexible and
dynamic, so it can adapt to the terrain and other dynamic objects that can be added to the map.
\end{abstract}
     
\begin{resumo} 
O algorítimo A* é o algorítimo de busca mais utilizado na industria de games e robótica,
entretanto apesar de ser um dos melhores algorítimos para busca de menor caminho, o
pre-processamento necessário em sua versão original dificulta a sua execução em ambientes
dinâmicos. Para solucionar este problema este artigo explora a possibilidade de tornar o
algoritmo A* mais flexível e dinâmico, para que ele se adapte ao terreno e outros objetos
dinâmicos que podem ser inseridos no mapa.
\end{resumo}


\section{Introdução}

A busca do menor caminho é um dos maiores problemas na industria de jogos e robótica.
Entre todos os algoritmos desenvolvidos para solucionar este problema o mais popular de todos é o A*.
O algoritmo A* tem sido cada vez mais optimizado, varias modificações e outras versões do algoritmo foram surgindo, 
buscando sempre aumentar sua velocidade e diminuir seu consumo de memoria, sem perder precisão \cite{modern}. Em busca de tornar o
algorítimo mais flexível e adaptável, este artigo sugere uma técnica de optimização que envolve a definição de tipos
para as células do mapa que mudam a forma com que o algorítimo encontra seus vizinhos, adaptando o algorítimo as
diferentes propriedades do mapa.

\section{Algorítimos de busca}

Existem dois tipos de algorítimos de busca de menor caminho, não-direcionados, como a busca em largura ou em profundidade,
estes algorítimos não possuem nenhuma heurística, eles correm cegamente pelo mapa, ja os algorítimos direcionados como o Dijkstra e o A*
tentam escolher a melhor rota para seu destino. Algorítimos direcionados realizam mais iterações do que os não-direcionados,
entretanto eles retornam sempre o menor caminho, para qual é dado maior importância \cite{computer}.

\subsection{Algorítimo A*}

O algorítimo A* seleciona uma célula inicial, analisa cada uma das células vizinhas e verifica uma estimativa do custo da rota ate a célula
destino a partir daquela célula vizinha. Armazenando em cada célula o custo do caminho ate ela e a distancia estimada dela ate a célula destino,
o algorítimo A* mistura propriedades de dois algorítimos de busca, Dijkstra e "Melhor-Primeiro". Ele depende de uma função heurística
que calcula esta estimativa, quanto mais precisa a função heurística, maior a garantia de que o algorítimo retornara o menor caminho \cite{smart}.\\
O funcionamento do A* em pseudocódigo \cite{computer}:\\
\hspace*{10mm}g - custo para chegar ate a célula\\
\hspace*{10mm}h - estimativa da distancia ate o destino\\
\hspace*{10mm}f - soma de g e h, estimativa de qual sera o menor caminho\\\\
\hspace*{10mm}1. Define-se P como célula de inicio.\\
\hspace*{10mm}2. Define-se os valores f, g e h de P.\\
\hspace*{10mm}3. Adiciona-se P a lista de células abertas.\\
\hspace*{10mm}4. Define-se B como a melhor célula da lista aberta (que possui menor f).\\
\hspace*{10mm}\hspace{10mm}a. Se B for a célula destino, o caminho foi encontrado.\\
\hspace*{10mm}\hspace{10mm}b. Se não existir células na lista aberta, não existe um caminho.\\
\hspace*{10mm}5. Define-se C como uma célula valida, vizinha a B.\\
\hspace*{10mm}\hspace{10mm}a. Define-se os valores f, g e h de C.\\
\hspace*{10mm}\hspace{10mm}b. Verifica se C esta na lista aberta ou fechada.\\
\hspace*{10mm}\hspace{10mm}\hspace{10mm}i. Se estiver na aberta, verifica-se se seu f é menor pelo novo caminho.\\
\hspace*{10mm}\hspace{10mm}\hspace{10mm}ii. Se estive na fechada, atualizamos a sua célula parente.\\
\hspace*{10mm}\hspace{10mm}\hspace{10mm}iii. Se não estiver em nenhuma, adiciona-se C a lista de células abertas.\\
\hspace*{10mm}\hspace{10mm}c. Repete-se a etapa 5 para todos os vizinhos de B.\\
\hspace*{10mm}6. Repete-se a partir da etapa 4.

\begin{figure}[ht]
	\centering
	\includegraphics[width=.7\textwidth]{astar.png}
	\caption{Exemplo do algorítimo A* em funcionamento denotando os valores de
		f no canto superior esquerdo, g no canto inferior esquerdo, e h no canto inferior direito. 
		\cite{begginers}}
	\label{fig:astar}
\end{figure}

\subsection{Limitações}

Devido ao seu pre-processamento e o alto uso de memoria, existe uma grande dificuldade em fazer com que este algorítimo suporte ambientes dinâmicos,
uma célula não pode mudar de estado, custo ou quantidade de vizinhos apos o pre-processamento, este novo dado sera ignorado pelo calculo de menor caminho
do algorítimo. Quanto mais agentes executando o algorítimo, mais recursos de processamento e memoria serão necessários para sua execução.
Um dos maiores limitadores na industria de jogos seria o algorítimo A* e o quanto esta industria depende dele. Invés de desenvolverem novos conceitos,
desenvolvedores preferem modificar suas ideias iniciais para se encaixarem a estas limitações, muitas vezes diminuindo o potencial do produto final \cite{computer}.

\subsection{Optimização}

Adicionando a cada célula do algorítimo um tipo que informa ao algorítimo como interpretar os vizinhos desta célula especifica.
Podemos criar células de tipo hexagonais, ou quadradas, ou de qualquer tipo, afinal estas grades de células hexagonais e quadradas com as quais estamos acostumados são
apenas representações dos vizinhos de cada célula através de barreiras físicas, nada impede a criação de um tipo de célula que possua uma especie de túnel que a conecte com uma outra
célula que não esta conecta fisicamente a ela. Utilizando esta técnica, é possível a criação de um algorítimo A* que se adapte a qualquer tipo de célula que esta sendo analisada pelo algorítimo.

\begin{figure}[ht]
	\centering
	\includegraphics[width=.7\textwidth]{optimizacao.png}
	\caption{Esta figura demonstra o algorítimo optimizado em execução
		para grades de células com tipos diferentes.}
	\label{fig:optimizacao}
\end{figure}


\section{Agradecimentos}

Agradeço ao professor Pedro Cacique assim como a todos os outros professores da FCI por seus ensinamentos.

\section{Referências}

\bibliographystyle{sbc}
\bibliography{sbc-template}

\end{document}
